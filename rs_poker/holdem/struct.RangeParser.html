<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `RangeParser` struct in crate `rs_poker`."><meta name="keywords" content="rust, rustlang, rust-lang, RangeParser"><title>rs_poker::holdem::RangeParser - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Struct RangeParser</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.parse_one">parse_one</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-From">From</a><a href="#impl-Into">Into</a><a href="#impl-TryFrom">TryFrom</a><a href="#impl-Borrow">Borrow</a><a href="#impl-BorrowMut">BorrowMut</a><a href="#impl-TryInto">TryInto</a><a href="#impl-Any">Any</a></div></div><p class='location'><a href='../index.html'>rs_poker</a>::<wbr><a href='index.html'>holdem</a></p><script>window.sidebarCurrent = {name: 'RangeParser', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#210' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>rs_poker</a>::<wbr><a href='index.html'>holdem</a>::<wbr><a class="struct" href=''>RangeParser</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct RangeParser;</pre></div><div class='docblock'><p>Unit struct to provide starting hand parse functions. Use this to parse things
like <code>RangeParser::parse_one(&quot;AKo&quot;)</code> and <code>RangeParser::parse_one(&quot;TT+&quot;)</code></p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="struct" href="../../rs_poker/holdem/struct.RangeParser.html" title="struct rs_poker::holdem::RangeParser">RangeParser</a></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#212-525' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.parse_one' class="method"><span id='parse_one.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.parse_one' class='fnname'>parse_one</a>(r_str: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../rs_poker/core/struct.Hand.html" title="struct rs_poker::core::Hand">Hand</a>&gt;, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#357-524' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Parse a string and return all the starting hands</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>You can send in hands where the suits are specified for all hands.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;

<span class="kw">let</span> <span class="ident">hand</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AhKh&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">1</span>, <span class="ident">hand</span>.<span class="ident">len</span>());</pre>
<p>You can also specify hands were the suits are not specified,
but you want them to be suited.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AKs&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hands</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">4</span>);
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">Ace</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">King</span>, <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
}</pre>
<p>You can also specify that the cards are not of the same suit.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AKo&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">!=</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">Ace</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">King</span>, <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
}</pre>
<p>You can also use the + modifier after a set of
starting cards. The modifier will mean different things
for different sets of cards.</p>
<p>If the starting cards are pairs then the + means all pairs
equal to or above the specified values.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;TT+&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
}</pre>
<p>If the cards are connectors then the plus means all
connectors where the cards are above the specified
values.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;T9o+&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>, <span class="ident">Value</span>::<span class="ident">from_u8</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">+</span> <span class="number">1</span>));
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">!=</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
}</pre>
<p>If the cards are not paired and not connectors then plus
after the hand means all hands where the second card
is greater than or equal to the specified second card,
and below the first card.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;A9s+&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Nine</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
}</pre>
<p>It's also possible to do more complex ranges using
dash modifer. For example if you wanted to represent
Suited middle connectors you could do something like this.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;JT-67s&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="comment">// The largest card is always the first</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="comment">// first card is great or equal to seven</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Seven</span>);
    <span class="comment">// Second card is greater or equal to six</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Six</span>);
    <span class="comment">// First card is less than or equal to Jack</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&lt;=</span> <span class="ident">Value</span>::<span class="ident">Jack</span>);
    <span class="comment">// Second card is less than or equal to Ten</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&lt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
    <span class="comment">// All hands are connectors.</span>
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">1</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>.<span class="ident">gap</span>(<span class="kw-2">&amp;</span><span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>));
}</pre>
<p>Also with the dash modifier there's no need to only have
connected cards. It's possible to represent ranges with gappers.
For example if you wanted to do high one gappers.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AQ-J9&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hands = {:?}&quot;</span>, <span class="ident">hands</span>);</pre>
<p>Since the dash modifier represents a range the difference
between cards ( the gap ) must remain constant.
If it's not parse_one will return an <code>Err</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="comment">// This will not work since the difference between Ace and King is one</span>
<span class="comment">// while the diffence between Jack and Nine is two.</span>
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AK-J9&quot;</span>).<span class="ident">unwrap</span>();
<span class="comment">// We&#39;ll never get here</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hands = {:?}&quot;</span>, <span class="ident">hands</span>);</pre>
</div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../rs_poker/holdem/struct.RangeParser.html" title="struct rs_poker::holdem::RangeParser">RangeParser</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../rs_poker/holdem/struct.RangeParser.html" title="struct rs_poker::holdem::RangeParser">RangeParser</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a> for T</code><a href='#impl-From' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#462-464' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from' class="method"><span id='from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#463' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#453-458' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.into' class="method"><span id='into.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#455-457' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;U&gt;,&nbsp;</span></code><a href='#impl-TryFrom' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#481-487' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><span id='Error.t' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.never.html">!</a></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method"><span id='try_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#484-486' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219-221' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.borrow' class="method"><span id='borrow.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#220' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#224-226' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method"><span id='borrow_mut.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#225' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-TryInto' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#469-476' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><span id='Error.t-1' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method"><span id='try_into.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#473-475' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Any' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#114-116' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.get_type_id' class="method"><span id='get_type_id.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.get_type_id' class='fnname'>get_type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#115' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>get_type_id</code>)</summary><p>this method will likely be replaced by an associated static</p>
</details></div></div><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.get_type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rs_poker";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>